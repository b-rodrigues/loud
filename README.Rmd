---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# loud

<!-- badges: start -->
<!-- badges: end -->

Easily add logs to your functions.

## Installation

You can install the development version of loud from [GitHub](https://github.com/) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("b-rodrigues/loud@release_0.1.1")
```

## Introduction

{loud} allows you to decorate functions make them provide enhanced output:


```{r example}
library(loud)

loud_sqrt <- loudly(sqrt)

a <- loud_sqrt(1:5)

```

Object `a` is now an object of class `loud`. The value of the `sqrt()` function applied to its arguments
can be obtained using `pick()`:

```{r}
pick(a, "value")
```

A log also gets generated and can be read using `read_log()`:

```{r}
read_log(a)
```
This is especially useful for objects that get created using multiple calls:

```{r}

loud_sqrt <- loudly(sqrt)
loud_exp <- loudly(exp)
loud_mean <- loudly(mean)

b <- 1:10 |>
  loud_sqrt() |>
  bind_loudly(loud_exp) |>
  bind_loudly(loud_mean)

```

```{r}
read_log(b)

pick(b, "value")
```

## Composing decorated functions

`bind_loudly()` is used to pass the output from one decorated function to the next.

`loudly()` works with any function:

```{r}
library(dplyr)

loud_group_by <- loudly(group_by)
loud_select <- loudly(select)
loud_summarise <- loudly(summarise)
loud_filter <- loudly(filter)

output <- starwars %>%
  loud_select(height, mass, species, sex) %>%
  bind_loudly(loud_group_by, species, sex) %>%
  bind_loudly(loud_filter, sex != "male") %>%
  bind_loudly(loud_summarise,
              mass = mean(mass, na.rm = TRUE)
              )

```

```{r}
read_log(output)
```

The value can then be accessed and worked on as usual using `pick()`:

```{r}
pick(output, "value")
```

This package also ships with a dedicated pipe, `%>=%` which you can use instead of `bind_loudly()`:

```{r}
output_pipe <- starwars %>%
  loud_value() %>=%
  loud_select(height, mass, species, sex) %>=%
  loud_group_by(species, sex) %>=%
  loud_filter(sex != "male") %>=%
  loud_summarise(mass = mean(mass, na.rm = TRUE))

```

```{r}
pick(output_pipe, "value")
```

Objects of class `loud` have their own print method:

```{r}
output_pipe
```

## Condition handling

By default, errors and warnings get caught and composed in the log:

```{r}

errord_output <- starwars %>%
  loud_value() %>=%
  loud_select(height, mass, species, sex) %>=% 
  loud_group_by(species, sx) %>=% # type, "sx" instead of "sex"
  loud_filter(sex != "male") %>=%
  loud_summarise(mass = mean(mass, na.rm = TRUE))

```

```{r}
errord_output
```

Reading the log tells you which function failed, and with which error message:

```{r}
read_log(errord_output)
```

It is also possible to only capture errors, or catpure errors, warnings and messages using
the `strict` parameter of `loud()`

```{r}
# Only errors:

loud_sqrt <- loudly(sqrt, strict = 1)

loud_sqrt(-10) |>
  read_log()

# Errors and warnings:

loud_sqrt <- loudly(sqrt, strict = 2)

loud_sqrt(-10) |>
  read_log()

# Errors, warnings and messages

my_f <- function(x){
  message("this is a message")
  10
}

loudly(my_f, strict = 3)(10) |>
                         read_log()

```

## Caution

This packages is in early development and basically is held together with string and j*zz. Use at
your own peril, but it has some tests now that pass, so it shouldn't be too bad. That being said,
if you used it for serious work and it turns out that your house caught on fire, that's on you.

## Thanks

Iâ€™d like to thank [armcn](https://github.com/armcn), [Kupac](https://github.com/Kupac) for their
blog posts ([here](https://kupac.gitlab.io/biofunctor/2019/05/25/maybe-monad-in-r/)) and 
packages ([maybe](https://armcn.github.io/maybe/)) which inspired me to build this package.
